{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction This self-service course provides a general introduction to High Performance Computing (HPC) using EPCC's national HPC service ARCHER2 as the platform for the exercises. Details High-performance computing (HPC) is a fundamental technology used in solving scientific problems. Many of the grand challenges of science depend on simulations and models run on HPC facilities to make progress, for example: protein folding, the search for the Higgs boson, and developing nuclear fusion. This self-service course covers the the basic concepts underlying the drivers for HPC development, HPC hardware, software, programming models, applications, HPC usage, and application performance.This foundation will give the you ability to appreciate the relevance of HPC in your field and also equip you with the tools to start making effective use of HPC facilities yourself. Intended learning outcomes On completion of this course trainees should be able to explain: Why HPC? - What are the drivers and motivation? who uses it? HPC Hardware - Building blocks and architectures. Parallel computing - Programing models and implementations. Using HPC systems - Access, compilers, resource allocation and performance. Pre-requisites Trainees are expected to have experience using a desktop computer (Windows or Mac), but no programming, Linux, or HPC experience is necessary. Timetable This is a self-service course which you can work through at your own pace and in your own time. Each section contains an approximate guide to how long it would take to cover if it was delivered in traditional lecture style. Overview of EPCC Why HPC? HPC systems oview Exercise 1 - Connecting to and using a supercomputer Hardware and architecture details Parallel programming Exercise 2 - running parallel programs Parallel performance Exercise 3 - parallel performance","title":"Introduction"},{"location":"#introduction","text":"This self-service course provides a general introduction to High Performance Computing (HPC) using EPCC's national HPC service ARCHER2 as the platform for the exercises.","title":"Introduction"},{"location":"#details","text":"High-performance computing (HPC) is a fundamental technology used in solving scientific problems. Many of the grand challenges of science depend on simulations and models run on HPC facilities to make progress, for example: protein folding, the search for the Higgs boson, and developing nuclear fusion. This self-service course covers the the basic concepts underlying the drivers for HPC development, HPC hardware, software, programming models, applications, HPC usage, and application performance.This foundation will give the you ability to appreciate the relevance of HPC in your field and also equip you with the tools to start making effective use of HPC facilities yourself.","title":"Details"},{"location":"#intended-learning-outcomes","text":"On completion of this course trainees should be able to explain: Why HPC? - What are the drivers and motivation? who uses it? HPC Hardware - Building blocks and architectures. Parallel computing - Programing models and implementations. Using HPC systems - Access, compilers, resource allocation and performance.","title":"Intended learning outcomes"},{"location":"#pre-requisites","text":"Trainees are expected to have experience using a desktop computer (Windows or Mac), but no programming, Linux, or HPC experience is necessary.","title":"Pre-requisites"},{"location":"#timetable","text":"This is a self-service course which you can work through at your own pace and in your own time. Each section contains an approximate guide to how long it would take to cover if it was delivered in traditional lecture style. Overview of EPCC Why HPC? HPC systems oview Exercise 1 - Connecting to and using a supercomputer Hardware and architecture details Parallel programming Exercise 2 - running parallel programs Parallel performance Exercise 3 - parallel performance","title":"Timetable"},{"location":"EPCC/","text":"Overview of EPCC","title":"EPCC"},{"location":"EPCC/#overview-of-epcc","text":"","title":"Overview of EPCC"},{"location":"HPC_systems_overview/","text":"Basics of HPC systems What is a supercomputer? Linux, the command line, and SSH Some example systems Interactive vs Batch use Leads to: You should now try the first practical exercise: Exercise 1","title":"Basics of HPC systems"},{"location":"HPC_systems_overview/#basics-of-hpc-systems","text":"","title":"Basics of HPC systems"},{"location":"HPC_systems_overview/#what-is-a-supercomputer","text":"","title":"What is a supercomputer?"},{"location":"HPC_systems_overview/#linux-the-command-line-and-ssh","text":"","title":"Linux, the command line, and SSH"},{"location":"HPC_systems_overview/#some-example-systems","text":"","title":"Some example systems"},{"location":"HPC_systems_overview/#interactive-vs-batch-use","text":"","title":"Interactive vs Batch use"},{"location":"HPC_systems_overview/#leads-to","text":"You should now try the first practical exercise: Exercise 1","title":"Leads to:"},{"location":"ex2/","text":"Practical exercise 2 In this practial exercise you will: Compile and run MPI code Investiagate parrallel taskfarms and worksharing The source code required for this exercise is on this github repo: https://github.com/sfarr-epcc/fractal","title":"Exercise 2 - running parallel programs"},{"location":"ex2/#practical-exercise-2","text":"In this practial exercise you will: Compile and run MPI code Investiagate parrallel taskfarms and worksharing The source code required for this exercise is on this github repo: https://github.com/sfarr-epcc/fractal","title":"Practical exercise 2"},{"location":"ex3/","text":"Practical exercise 3 In this exercise you will: - compile and run difference version of the same code: Serial, OpenMP,MPI, C, Fortran, Python - Perform benchmarking of the code, investigating the strong scaling, the weak scaling, and serial performance of the different languages and parallelisation techniques The case study code for this exercise is a 2D Computational Fluid Dynamics (CFD) code. The content is all contained in this seperate webpage: Exercise 3 - CFD Github repo of the source code: https://github.com/sfarr-epcc/cfd","title":"Exercise 3 - parallel performance"},{"location":"ex3/#practical-exercise-3","text":"In this exercise you will: - compile and run difference version of the same code: Serial, OpenMP,MPI, C, Fortran, Python - Perform benchmarking of the code, investigating the strong scaling, the weak scaling, and serial performance of the different languages and parallelisation techniques The case study code for this exercise is a 2D Computational Fluid Dynamics (CFD) code. The content is all contained in this seperate webpage: Exercise 3 - CFD Github repo of the source code: https://github.com/sfarr-epcc/cfd","title":"Practical exercise 3"},{"location":"hardware_and_architectures/","text":"HPC Hardware and architectures","title":"Hardware and architecture details"},{"location":"hardware_and_architectures/#hpc-hardware-and-architectures","text":"","title":"HPC Hardware and architectures"},{"location":"optimization/","text":"Optimization Basics of efficient programming (some basic C/C++ or Fortran knowldegde needed) Optimization caveats compiler flags Fast CPU operations vs microcode C vs Fortran style 2D array indexing Loop optimizations Avoiding branching Helping the compiler","title":"Optimization"},{"location":"optimization/#optimization","text":"Basics of efficient programming (some basic C/C++ or Fortran knowldegde needed) Optimization caveats compiler flags Fast CPU operations vs microcode C vs Fortran style 2D array indexing Loop optimizations Avoiding branching Helping the compiler","title":"Optimization"},{"location":"parallel_performance/","text":"Parallel performance Serial performance programming languages different compilers compiler flags strong scaling Amdahl's law Weak scaling Gustafson's law Other considerations Hybrid OpenMP and MPI","title":"Parallel performance"},{"location":"parallel_performance/#parallel-performance","text":"","title":"Parallel performance"},{"location":"parallel_performance/#serial-performance","text":"programming languages different compilers compiler flags","title":"Serial performance"},{"location":"parallel_performance/#strong-scaling","text":"Amdahl's law","title":"strong scaling"},{"location":"parallel_performance/#weak-scaling","text":"Gustafson's law","title":"Weak scaling"},{"location":"parallel_performance/#other-considerations","text":"Hybrid OpenMP and MPI","title":"Other considerations"},{"location":"parallel_programming/","text":"Parallel programming Parallel programing patterns Shared memory Distributed memory OpenMP MPI CUDA/GPU programming","title":"Parallel programming"},{"location":"parallel_programming/#parallel-programming","text":"","title":"Parallel programming"},{"location":"parallel_programming/#parallel-programing-patterns","text":"","title":"Parallel programing patterns"},{"location":"parallel_programming/#shared-memory","text":"","title":"Shared memory"},{"location":"parallel_programming/#distributed-memory","text":"","title":"Distributed memory"},{"location":"parallel_programming/#openmp","text":"","title":"OpenMP"},{"location":"parallel_programming/#mpi","text":"","title":"MPI"},{"location":"parallel_programming/#cudagpu-programming","text":"","title":"CUDA/GPU programming"},{"location":"why_HPC/","text":"What is HPC and why is it needed?","title":"Why HPC?"},{"location":"why_HPC/#what-is-hpc-and-why-is-it-needed","text":"","title":"What is HPC and why is it needed?"},{"location":"ex1/ex1/","text":"Practical exercise 1 In this practical exercise you will: Access ARCHER2, or Cirrus, or a Machine of your choice using SSH. Become familiar with linux and the command line. Compile and run serial code interactively. Submit serial and parallel programs to run using the batch system. The case study code for this exercise is a image sharpening program. The source code we will use is on this Github repo: https://github.com/sfarr-epcc/image_sharpening The exercise is split into a few parts that should be done in order: Optional: Theory of the case-study program Part 1: Connecting to a HPC machine with SSH Part 2: Compilation and running Part 3: Job submission","title":"Overview"},{"location":"ex1/ex1/#practical-exercise-1","text":"In this practical exercise you will: Access ARCHER2, or Cirrus, or a Machine of your choice using SSH. Become familiar with linux and the command line. Compile and run serial code interactively. Submit serial and parallel programs to run using the batch system. The case study code for this exercise is a image sharpening program. The source code we will use is on this Github repo: https://github.com/sfarr-epcc/image_sharpening The exercise is split into a few parts that should be done in order: Optional: Theory of the case-study program Part 1: Connecting to a HPC machine with SSH Part 2: Compilation and running Part 3: Job submission","title":"Practical exercise 1"},{"location":"ex1/part1/","text":"Part 1 This page covers how to log into a remote machine. SSH client To connect to a remote computer you will need a SSH client. SSH is a tool that allows us to connect to and use a remote computer as our own. Please follow the directions below to install an SSH client for your system if you do not already have one. Windows Modern versions of Windows have SSH available in Powershell. You can test if it is available by typing ssh --help in Powershell. If it is installed, you should see some useful output. If it is not installed, you will get an error. If SSH is not available in Powershell, then you should install MobaXterm from http://mobaxterm.mobatek.net . You will want to get the Home edition (Installer edition). However, if Powershell works, you do not need this. macOS macOS comes with SSH pre-installed, so you should not need to install anything. Use your \"Terminal\" app. Linux Linux users do not need to install anything, you should be set! Use your terminal application. Acount on an EPCC machine, ARCHER2 or Cirrus If you are doing this exercise on EPCC mchaines ARCHER2 or Cirrus you will need to make an account. The first step is the same for both machines. Sign up for a SAFE account To sign up, you must first register for an account on SAFE (our service administration web application): If you are already registered on the ARCHER or Tier-2 SAFE you do not need to re-register. Please proceed to the next step. Go to the SAFE New User Signup Form Fill in your personal details. You can come back later and change them if you wish. Note: you should register using your institutional or company email address - email domains such as gmail.com, outlook.com, etc. are not allowed to be used for access to ARCHER2 Click \u201cSubmit\u201d You are now registered. A single use login link will be emailed to the email address you provided. You can use this link to login and set your password. Now choose ARCHER2 or Cirrus ARCHER2 Sign up for an account on ARCHER2 through SAFE Login to SAFE Go to the Menu \"Login accounts\" and select \"Request login account\" Choose the TODO project \u201cChoose Project for Machine Account\u201d box and click \"Next\" On the next page, the ARCHER2 system should be selected. Click \"Next\" Enter the username you would prefer to use on ARCHER2. Every username must be unique, so if your chosen name is taken, you will need to choose another Now you have to wait for the course organiser to accept your request to register. When this has happened, your account will be created on ARCHER2. Once this has been done, you should be sent an email. If you have not received an email but believe that your account should have been activated, check your account status in SAFE which will also show when the account has been activated. You can then pick up your one shot initial password for ARCHER2 from your SAFE account. Generate an SSH key pair and upload it to SAFE In addition to your password, you will need an SSH key pair to access ARCHER2. There is useful guidance on how to generate SSH key pairs in the ARCHER2 documentation . Once you have generated your key pair, you need to add the public part to your ARCHER2 account in SAFE: Login to SAFE Go to the Menu \u201cLogin accounts\u201d and select the ARCHER2 account you want to add the SSH key to On the subsequent Login account details page click the \u201cAdd Credential\u201d button Select \u201cSSH public key\u201d as the Credential Type and click \u201cNext\u201d Either copy and paste the public part of your SSH key into the \u201cSSH Public key\u201d box or use the button to select the public key file on your computer. Click \u201cAdd\u201d to associate the public SSH key part with your account The public SSH key part will now be added to your login account on the ARCHER2 system. Log into ARCHER2 You should now be able to log into ARCHER2 by following the login instructions in the ARCHER2 documentation . Cirrus Sign up for an account on Cirrus through SAFE Login to SAFE Go to the Menu \"Login accounts\" and select \"Request login account\" Choose the TODO project \u201cChoose Project for Machine Account\u201d box and click \"Next\" On the next page, the Cirrus system should be selected. Click \"Next\" Enter the username you would prefer to use on Cirrus. Every username must be unique, so if your chosen name is taken, you will need to choose another Now you have to wait for the course organiser to accept your request to register. When this has happened, your account will be created on Cirrus. Once this has been done, you should be sent an email. If you have not received an email but believe that your account should have been activated, check your account status in SAFE which will also show when the account has been activated. You can then pick up your one shot initial password for Cirrus from your SAFE account. Generate an SSH key pair and upload it to SAFE In addition to your password, you will need an SSH key pair to access Cirrus. There is useful guidance on how to generate SSH key pairs in the Cirrus documentation . Once you have generated your key pair, you need to add the public part to your Cirrus account in SAFE: Login to SAFE Go to the Menu \u201cLogin accounts\u201d and select the Cirrus account you want to add the SSH key to On the subsequent Login account details page click the \u201cAdd Credential\u201d button Select \u201cSSH public key\u201d as the Credential Type and click \u201cNext\u201d Either copy and paste the public part of your SSH key into the \u201cSSH Public key\u201d box or use the button to select the public key file on your computer. Click \u201cAdd\u201d to associate the public SSH key part with your account The public SSH key part will now be added to your login account on the Cirrus system. Log into Cirrus You should now be able to log into Cirrus by following the login instructions in the Cirrus documentation .","title":"Part 1"},{"location":"ex1/part1/#part-1","text":"This page covers how to log into a remote machine.","title":"Part 1"},{"location":"ex1/part1/#ssh-client","text":"To connect to a remote computer you will need a SSH client. SSH is a tool that allows us to connect to and use a remote computer as our own. Please follow the directions below to install an SSH client for your system if you do not already have one. Windows Modern versions of Windows have SSH available in Powershell. You can test if it is available by typing ssh --help in Powershell. If it is installed, you should see some useful output. If it is not installed, you will get an error. If SSH is not available in Powershell, then you should install MobaXterm from http://mobaxterm.mobatek.net . You will want to get the Home edition (Installer edition). However, if Powershell works, you do not need this. macOS macOS comes with SSH pre-installed, so you should not need to install anything. Use your \"Terminal\" app. Linux Linux users do not need to install anything, you should be set! Use your terminal application.","title":"SSH client"},{"location":"ex1/part1/#acount-on-an-epcc-machine-archer2-or-cirrus","text":"If you are doing this exercise on EPCC mchaines ARCHER2 or Cirrus you will need to make an account. The first step is the same for both machines.","title":"Acount on an EPCC machine, ARCHER2 or Cirrus"},{"location":"ex1/part1/#sign-up-for-a-safe-account","text":"To sign up, you must first register for an account on SAFE (our service administration web application): If you are already registered on the ARCHER or Tier-2 SAFE you do not need to re-register. Please proceed to the next step. Go to the SAFE New User Signup Form Fill in your personal details. You can come back later and change them if you wish. Note: you should register using your institutional or company email address - email domains such as gmail.com, outlook.com, etc. are not allowed to be used for access to ARCHER2 Click \u201cSubmit\u201d You are now registered. A single use login link will be emailed to the email address you provided. You can use this link to login and set your password. Now choose ARCHER2 or Cirrus ARCHER2","title":"Sign up for a SAFE account"},{"location":"ex1/part1/#sign-up-for-an-account-on-archer2-through-safe","text":"Login to SAFE Go to the Menu \"Login accounts\" and select \"Request login account\" Choose the TODO project \u201cChoose Project for Machine Account\u201d box and click \"Next\" On the next page, the ARCHER2 system should be selected. Click \"Next\" Enter the username you would prefer to use on ARCHER2. Every username must be unique, so if your chosen name is taken, you will need to choose another Now you have to wait for the course organiser to accept your request to register. When this has happened, your account will be created on ARCHER2. Once this has been done, you should be sent an email. If you have not received an email but believe that your account should have been activated, check your account status in SAFE which will also show when the account has been activated. You can then pick up your one shot initial password for ARCHER2 from your SAFE account.","title":"Sign up for an account on ARCHER2 through SAFE"},{"location":"ex1/part1/#generate-an-ssh-key-pair-and-upload-it-to-safe","text":"In addition to your password, you will need an SSH key pair to access ARCHER2. There is useful guidance on how to generate SSH key pairs in the ARCHER2 documentation . Once you have generated your key pair, you need to add the public part to your ARCHER2 account in SAFE: Login to SAFE Go to the Menu \u201cLogin accounts\u201d and select the ARCHER2 account you want to add the SSH key to On the subsequent Login account details page click the \u201cAdd Credential\u201d button Select \u201cSSH public key\u201d as the Credential Type and click \u201cNext\u201d Either copy and paste the public part of your SSH key into the \u201cSSH Public key\u201d box or use the button to select the public key file on your computer. Click \u201cAdd\u201d to associate the public SSH key part with your account The public SSH key part will now be added to your login account on the ARCHER2 system.","title":"Generate an SSH key pair and upload it to SAFE"},{"location":"ex1/part1/#log-into-archer2","text":"You should now be able to log into ARCHER2 by following the login instructions in the ARCHER2 documentation . Cirrus","title":"Log into ARCHER2"},{"location":"ex1/part1/#sign-up-for-an-account-on-cirrus-through-safe","text":"Login to SAFE Go to the Menu \"Login accounts\" and select \"Request login account\" Choose the TODO project \u201cChoose Project for Machine Account\u201d box and click \"Next\" On the next page, the Cirrus system should be selected. Click \"Next\" Enter the username you would prefer to use on Cirrus. Every username must be unique, so if your chosen name is taken, you will need to choose another Now you have to wait for the course organiser to accept your request to register. When this has happened, your account will be created on Cirrus. Once this has been done, you should be sent an email. If you have not received an email but believe that your account should have been activated, check your account status in SAFE which will also show when the account has been activated. You can then pick up your one shot initial password for Cirrus from your SAFE account.","title":"Sign up for an account on Cirrus through SAFE"},{"location":"ex1/part1/#generate-an-ssh-key-pair-and-upload-it-to-safe_1","text":"In addition to your password, you will need an SSH key pair to access Cirrus. There is useful guidance on how to generate SSH key pairs in the Cirrus documentation . Once you have generated your key pair, you need to add the public part to your Cirrus account in SAFE: Login to SAFE Go to the Menu \u201cLogin accounts\u201d and select the Cirrus account you want to add the SSH key to On the subsequent Login account details page click the \u201cAdd Credential\u201d button Select \u201cSSH public key\u201d as the Credential Type and click \u201cNext\u201d Either copy and paste the public part of your SSH key into the \u201cSSH Public key\u201d box or use the button to select the public key file on your computer. Click \u201cAdd\u201d to associate the public SSH key part with your account The public SSH key part will now be added to your login account on the Cirrus system.","title":"Generate an SSH key pair and upload it to SAFE"},{"location":"ex1/part1/#log-into-cirrus","text":"You should now be able to log into Cirrus by following the login instructions in the Cirrus documentation .","title":"Log into Cirrus"},{"location":"ex1/part2/","text":"Part 2 This page covers how to download, compile, and run code. Downloading the source code In this exercerise we will be using a image sharpening program. The source code is available in a Github repository. At this stage we do not have to be concered about what Git is, only that Github is a common platform to distribute code. To download the code you will need to clone the repository. To do this execute the following command git clone https://github.com/sfarr-epcc/sharpen.git The output will look similar to this Cloning into 'sharpen'... remote: Enumerating objects: 21, done. remote: Counting objects: 100% (21/21), done. remote: Compressing objects: 100% (15/15), done. remote: Total 21 (delta 7), reused 16 (delta 5), pack-reused 0 Receiving objects: 100% (21/21), 314.18 KiB | 2.51 MiB/s, done. Resolving deltas: 100% (7/7), done. You will now have a folder called sharpen . Change directory into it and list the contents cd sharpen ls Output C-OMP C-SER README.md There are two version of the code, a serial version and a parallel version. Initially we will be looking at the serial version located in the C-SER folder. Compiling the source code We will compile the serial version of the source code using a Makefile. Move into the C-SER directory and list the contents. cd C-SER ls Output: cio.c dosharpen.c filter.c fuzzy.pgm Makefile sharpen.c sharpen.h utilities.c utilities.h You will see that there are various code files. The Makefile constains the commands to compile them together to produce the executable program. To use the Makefile type make command. make Output: cc -fopenmp -g -DC_OPENMP_PRACTICAL -c sharpen.c cc -fopenmp -g -DC_OPENMP_PRACTICAL -c dosharpen.c cc -fopenmp -g -DC_OPENMP_PRACTICAL -c filter.c cc -fopenmp -g -DC_OPENMP_PRACTICAL -c cio.c cc -fopenmp -g -DC_OPENMP_PRACTICAL -c utilities.c cc -fopenmp -g -DC_OPENMP_PRACTICAL -o sharpen sharpen.o dosharpen.o filter.o cio.o utilities.o -lm This should produce an executable file called sharpen . Running the serial progam We can run the serial program directly on the login nodes ./sharpen Output: Image sharpening code running in serial Input file is: fuzzy.pgm Image size is 564 x 770 Using a filter of size 17 x 17 Reading image file: fuzzy.pgm ... done Starting calculation ... Program on core 0-255 ... finished Writing output file: sharpened.pgm ... done Calculation time was 3.697039 seconds Overall run time was 3.923524 seconds Viewing the images To view the images on the remote machine you will need to make sure you an X window client installed on your local machine and you have logged into the remote mahcine with X forwarding enabled. Depending on the machine you will have different image viewing programs available. ARCHER2 module load xview xview file.pgm Cirrus module load ImageMagick display file.pgm Note Here we have introduced the module command, this is a way of controlling the software environment typically used on HPC machines. A module is a self-contained description of a software package -- it contains the settings required to run a software package and, usually, encodes required dependencies on other software packages. Alternatively you can download the files to your local machine via SSH ( scp , rysnc , or stfp ), see the ARHCER2 documentation or Cirrus documentation , and open them with an image viewing program e.g. preview on MacOS. The images should look like this: In the next step we will run the parallel version of the code on the compute nodes using the SLURM job submission system.","title":"Part 2"},{"location":"ex1/part2/#part-2","text":"This page covers how to download, compile, and run code.","title":"Part 2"},{"location":"ex1/part2/#downloading-the-source-code","text":"In this exercerise we will be using a image sharpening program. The source code is available in a Github repository. At this stage we do not have to be concered about what Git is, only that Github is a common platform to distribute code. To download the code you will need to clone the repository. To do this execute the following command git clone https://github.com/sfarr-epcc/sharpen.git The output will look similar to this Cloning into 'sharpen'... remote: Enumerating objects: 21, done. remote: Counting objects: 100% (21/21), done. remote: Compressing objects: 100% (15/15), done. remote: Total 21 (delta 7), reused 16 (delta 5), pack-reused 0 Receiving objects: 100% (21/21), 314.18 KiB | 2.51 MiB/s, done. Resolving deltas: 100% (7/7), done. You will now have a folder called sharpen . Change directory into it and list the contents cd sharpen ls Output C-OMP C-SER README.md There are two version of the code, a serial version and a parallel version. Initially we will be looking at the serial version located in the C-SER folder.","title":"Downloading the source code"},{"location":"ex1/part2/#compiling-the-source-code","text":"We will compile the serial version of the source code using a Makefile. Move into the C-SER directory and list the contents. cd C-SER ls Output: cio.c dosharpen.c filter.c fuzzy.pgm Makefile sharpen.c sharpen.h utilities.c utilities.h You will see that there are various code files. The Makefile constains the commands to compile them together to produce the executable program. To use the Makefile type make command. make Output: cc -fopenmp -g -DC_OPENMP_PRACTICAL -c sharpen.c cc -fopenmp -g -DC_OPENMP_PRACTICAL -c dosharpen.c cc -fopenmp -g -DC_OPENMP_PRACTICAL -c filter.c cc -fopenmp -g -DC_OPENMP_PRACTICAL -c cio.c cc -fopenmp -g -DC_OPENMP_PRACTICAL -c utilities.c cc -fopenmp -g -DC_OPENMP_PRACTICAL -o sharpen sharpen.o dosharpen.o filter.o cio.o utilities.o -lm This should produce an executable file called sharpen .","title":"Compiling the source code"},{"location":"ex1/part2/#running-the-serial-progam","text":"We can run the serial program directly on the login nodes ./sharpen Output: Image sharpening code running in serial Input file is: fuzzy.pgm Image size is 564 x 770 Using a filter of size 17 x 17 Reading image file: fuzzy.pgm ... done Starting calculation ... Program on core 0-255 ... finished Writing output file: sharpened.pgm ... done Calculation time was 3.697039 seconds Overall run time was 3.923524 seconds","title":"Running the serial progam"},{"location":"ex1/part2/#viewing-the-images","text":"To view the images on the remote machine you will need to make sure you an X window client installed on your local machine and you have logged into the remote mahcine with X forwarding enabled. Depending on the machine you will have different image viewing programs available. ARCHER2 module load xview xview file.pgm Cirrus module load ImageMagick display file.pgm Note Here we have introduced the module command, this is a way of controlling the software environment typically used on HPC machines. A module is a self-contained description of a software package -- it contains the settings required to run a software package and, usually, encodes required dependencies on other software packages. Alternatively you can download the files to your local machine via SSH ( scp , rysnc , or stfp ), see the ARHCER2 documentation or Cirrus documentation , and open them with an image viewing program e.g. preview on MacOS. The images should look like this: In the next step we will run the parallel version of the code on the compute nodes using the SLURM job submission system.","title":"Viewing the images"},{"location":"ex1/part3/","text":"Part 3 This page covers running parallel code on compute nodes using the job submission system. Compile the parallel version of the code cd C-OMP make Output: cc -fopenmp -g -DC_OPENMP_PRACTICAL -c sharpen.c cc -fopenmp -g -DC_OPENMP_PRACTICAL -c dosharpen.c cc -fopenmp -g -DC_OPENMP_PRACTICAL -c filter.c cc -fopenmp -g -DC_OPENMP_PRACTICAL -c cio.c cc -fopenmp -g -DC_OPENMP_PRACTICAL -c utilities.c cc -fopenmp -g -DC_OPENMP_PRACTICAL -o sharpen sharpen.o dosharpen.o filter.o cio.o utilities.o -lm To run this code in parallel it should be submitted to the compute nodes using Slurm workload manager. Note On ARCHER2 this code will not run correctly on the login nodes, it must be run on a compute node. Only serial programs are allowed to run on ARCHER2 login nodes. On Cirrus this code will run on the login nodes. If you do this make sure you set the number of OpenMP threads to a small number -- although parallel programs can be run on Cirrus login nodes this should only be done for small tests. E.g. export OMP_NUM_THREADS=4 ./sharpen Running on the compute nodes The use of compute nodes on ARCHER2 and Cirrus is mediated by the Slurm job submission system. Slurm is a scheduler which is used to ensure that all users get access to their fair share of resources, to make sure that the machine is as efficiently used as possible and to allow user to run jobs without having to be physically logged in. Whilst it is possible to run interactive jobs (jobs where you log directly into the compute nodes and run your executable there), and they are useful for debugging and development, they are not ideal for running long and/or large numbers of production jobs as you need to be physically interacting with the system to use them. The solution to this, and the method that users generally use to run jobs on systems like ARCHER2, is to run in batch mode. In this case you put the commands you wish to run in a file (called a job script) and the system executes the commands in sequence for you with no need for you to be interacting. Using Slurm job scripts You will notice in the C-OMP folder there are Slurm scripts archer2.slurm and cirrus.slurm . If you open one using a text editor ( nano , vi , or emacs ) nano archer2.slurm archer2.slurm #!/bin/bash #SBATCH --job-name=sharpen #SBATCH --nodes=1 #SBATCH --tasks-per-node=1 #SBATCH --cpus-per-task=4 #SBATCH --time=00:01:00 # Replace [budget code] below with your project code (e.g. t01) #SBATCH --account=[budget code] #SBATCH --partition=standard #SBATCH --qos=standard # Setup the batch environment module load epcc-job-env # Set the number of threads to the CPUs per task export OMP_NUM_THREADS = $SLURM_CPUS_PER_TASK # Launch the parallel job srun --hint = nomultithread --distribution = block:block ./sharpen cirrus.slurm #!/bin/bash #SBATCH --job-name=sharpen #SBATCH --nodes=1 #SBATCH --tasks-per-node=1 #SBATCH --cpus-per-task=4 #SBATCH --time=00:01:00 # Replace [budget code] below with your project code (e.g. t01) #SBATCH --account=[budget code] #SBATCH --partition=standard #SBATCH --qos=standard # Set the number of threads to the CPUs per task export OMP_NUM_THREADS = $SLURM_CPUS_PER_TASK # Launch the parallel job srun --cpu-bind = cores ./sharpen This is an OpenMP program so we control the number of parallel threads used with the --cpus-per-task variable. To submit the job to run on the compute nodes we use the sbatch command sbatch archer2.slurm Output: Submitted batch job 1793266 Where the number is the unique job ID. Monitoring the batch job The slurm command squeue can be used to show the status of the jobs. Without any options or arguments it lists all jobs known by the scheduler. squeue To show just your jobs add the -u $USER option squeue -u $USER Note that for this example it runs very quickly so you may not see it in the queue before it finishes running. Finding the output The Slurm system places the output from your job in a file called slurm-<jobID>.out . You can view it using the cat command cat slurm-1793266.out Output: Image sharpening code running on 4 thread(s) Input file is: fuzzy.pgm Image size is 564 x 770 Using a filter of size 17 x 17 Reading image file: fuzzy.pgm ... done Starting calculation ... Thread 0 on core 0 Thread 1 on core 1 Thread 2 on core 2 Thread 3 on core 3 ... finished Writing output file: sharpened.pgm ... done Calculation time was 0.970780 seconds Overall run time was 1.124198 seconds","title":"Part 3"},{"location":"ex1/part3/#part-3","text":"This page covers running parallel code on compute nodes using the job submission system.","title":"Part 3"},{"location":"ex1/part3/#compile-the-parallel-version-of-the-code","text":"cd C-OMP make Output: cc -fopenmp -g -DC_OPENMP_PRACTICAL -c sharpen.c cc -fopenmp -g -DC_OPENMP_PRACTICAL -c dosharpen.c cc -fopenmp -g -DC_OPENMP_PRACTICAL -c filter.c cc -fopenmp -g -DC_OPENMP_PRACTICAL -c cio.c cc -fopenmp -g -DC_OPENMP_PRACTICAL -c utilities.c cc -fopenmp -g -DC_OPENMP_PRACTICAL -o sharpen sharpen.o dosharpen.o filter.o cio.o utilities.o -lm To run this code in parallel it should be submitted to the compute nodes using Slurm workload manager. Note On ARCHER2 this code will not run correctly on the login nodes, it must be run on a compute node. Only serial programs are allowed to run on ARCHER2 login nodes. On Cirrus this code will run on the login nodes. If you do this make sure you set the number of OpenMP threads to a small number -- although parallel programs can be run on Cirrus login nodes this should only be done for small tests. E.g. export OMP_NUM_THREADS=4 ./sharpen","title":"Compile the parallel version of the code"},{"location":"ex1/part3/#running-on-the-compute-nodes","text":"The use of compute nodes on ARCHER2 and Cirrus is mediated by the Slurm job submission system. Slurm is a scheduler which is used to ensure that all users get access to their fair share of resources, to make sure that the machine is as efficiently used as possible and to allow user to run jobs without having to be physically logged in. Whilst it is possible to run interactive jobs (jobs where you log directly into the compute nodes and run your executable there), and they are useful for debugging and development, they are not ideal for running long and/or large numbers of production jobs as you need to be physically interacting with the system to use them. The solution to this, and the method that users generally use to run jobs on systems like ARCHER2, is to run in batch mode. In this case you put the commands you wish to run in a file (called a job script) and the system executes the commands in sequence for you with no need for you to be interacting.","title":"Running on the compute nodes"},{"location":"ex1/part3/#using-slurm-job-scripts","text":"You will notice in the C-OMP folder there are Slurm scripts archer2.slurm and cirrus.slurm . If you open one using a text editor ( nano , vi , or emacs ) nano archer2.slurm archer2.slurm #!/bin/bash #SBATCH --job-name=sharpen #SBATCH --nodes=1 #SBATCH --tasks-per-node=1 #SBATCH --cpus-per-task=4 #SBATCH --time=00:01:00 # Replace [budget code] below with your project code (e.g. t01) #SBATCH --account=[budget code] #SBATCH --partition=standard #SBATCH --qos=standard # Setup the batch environment module load epcc-job-env # Set the number of threads to the CPUs per task export OMP_NUM_THREADS = $SLURM_CPUS_PER_TASK # Launch the parallel job srun --hint = nomultithread --distribution = block:block ./sharpen cirrus.slurm #!/bin/bash #SBATCH --job-name=sharpen #SBATCH --nodes=1 #SBATCH --tasks-per-node=1 #SBATCH --cpus-per-task=4 #SBATCH --time=00:01:00 # Replace [budget code] below with your project code (e.g. t01) #SBATCH --account=[budget code] #SBATCH --partition=standard #SBATCH --qos=standard # Set the number of threads to the CPUs per task export OMP_NUM_THREADS = $SLURM_CPUS_PER_TASK # Launch the parallel job srun --cpu-bind = cores ./sharpen This is an OpenMP program so we control the number of parallel threads used with the --cpus-per-task variable. To submit the job to run on the compute nodes we use the sbatch command sbatch archer2.slurm Output: Submitted batch job 1793266 Where the number is the unique job ID.","title":"Using Slurm job scripts"},{"location":"ex1/part3/#monitoring-the-batch-job","text":"The slurm command squeue can be used to show the status of the jobs. Without any options or arguments it lists all jobs known by the scheduler. squeue To show just your jobs add the -u $USER option squeue -u $USER Note that for this example it runs very quickly so you may not see it in the queue before it finishes running.","title":"Monitoring the batch job"},{"location":"ex1/part3/#finding-the-output","text":"The Slurm system places the output from your job in a file called slurm-<jobID>.out . You can view it using the cat command cat slurm-1793266.out Output: Image sharpening code running on 4 thread(s) Input file is: fuzzy.pgm Image size is 564 x 770 Using a filter of size 17 x 17 Reading image file: fuzzy.pgm ... done Starting calculation ... Thread 0 on core 0 Thread 1 on core 1 Thread 2 on core 2 Thread 3 on core 3 ... finished Writing output file: sharpened.pgm ... done Calculation time was 0.970780 seconds Overall run time was 1.124198 seconds","title":"Finding the output"},{"location":"ex1/theory/","text":"Image sharpening program Images can be fuzzy from random noise and blurrings. A image can be sharpened by: detecting the edges combining the edges with the original image These steps are shown in figure 1. Figure 1. Image sharpening steps. Edge detection Edges can be detected using a Laplacian filter. The Laplacian \\(L(x,y)\\) is the second spatial derivative of the image intensity \\(I(x,y)\\) , this means it highlights regions of rapid intensity change, i.e the edges. \\( L(x,y) = \\frac{\\partial^2 I }{\\partial x^2} + \\frac{\\partial^2 I }{\\partial y^2} \\) In practice this detects noise in the image as edges, therefore a smoothing filter is applied first which takes the form of a Guassian. The Guassian filter \\(G(x,y)\\) approximates each pixel as a weighted average of its neighbors. \\( G(x,y) = \\frac{1}{2 \\pi \\sigma^2} e^{- (x^2+y^2)/(2 \\sigma^2)} \\) The two operations can be combined to give the Laplacian of Gaussian filter \\(LoG(x,y)\\) . \\( LoG(x,y) = -\\frac{1}{\\pi \\sigma^4} \\left( 1 - \\frac{x^2+y^2}{2 \\sigma^2}\\right) e^{- (x^2+y^2)/(2 \\sigma^2)} \\) These two fuctions \\(G(x,y)\\) and \\(LoG(x,y)\\) are graphed in figure 2. Figure 2. Gaussian and Laplacian of Gaussian filters Implementation To apply the LoG filter to an image the LoG filter must be turned into a discrete mask, that is a matrix of size 2d+1 x 2d+1 where d is an integer. We use d=8, therefore the LoG filter is a 17x17 square, it looks like this: Figure 3. LoG filter as a discerete mask To perform the convolution of this filter with original image the following operation is performed on each pixel \\( edges(i,j) = \\sum_{k=-d}^d \\sum_{k=-d}^d image(i + k, j + l) \\times filter(k,l) \\) The sharpened image is then created by adding the edges to the original image, with a scaling factor (See the source code for the full details).","title":"Theory (Optional)"},{"location":"ex1/theory/#image-sharpening-program","text":"Images can be fuzzy from random noise and blurrings. A image can be sharpened by: detecting the edges combining the edges with the original image These steps are shown in figure 1. Figure 1. Image sharpening steps.","title":"Image sharpening program"},{"location":"ex1/theory/#edge-detection","text":"Edges can be detected using a Laplacian filter. The Laplacian \\(L(x,y)\\) is the second spatial derivative of the image intensity \\(I(x,y)\\) , this means it highlights regions of rapid intensity change, i.e the edges. \\( L(x,y) = \\frac{\\partial^2 I }{\\partial x^2} + \\frac{\\partial^2 I }{\\partial y^2} \\) In practice this detects noise in the image as edges, therefore a smoothing filter is applied first which takes the form of a Guassian. The Guassian filter \\(G(x,y)\\) approximates each pixel as a weighted average of its neighbors. \\( G(x,y) = \\frac{1}{2 \\pi \\sigma^2} e^{- (x^2+y^2)/(2 \\sigma^2)} \\) The two operations can be combined to give the Laplacian of Gaussian filter \\(LoG(x,y)\\) . \\( LoG(x,y) = -\\frac{1}{\\pi \\sigma^4} \\left( 1 - \\frac{x^2+y^2}{2 \\sigma^2}\\right) e^{- (x^2+y^2)/(2 \\sigma^2)} \\) These two fuctions \\(G(x,y)\\) and \\(LoG(x,y)\\) are graphed in figure 2. Figure 2. Gaussian and Laplacian of Gaussian filters","title":"Edge detection"},{"location":"ex1/theory/#implementation","text":"To apply the LoG filter to an image the LoG filter must be turned into a discrete mask, that is a matrix of size 2d+1 x 2d+1 where d is an integer. We use d=8, therefore the LoG filter is a 17x17 square, it looks like this: Figure 3. LoG filter as a discerete mask To perform the convolution of this filter with original image the following operation is performed on each pixel \\( edges(i,j) = \\sum_{k=-d}^d \\sum_{k=-d}^d image(i + k, j + l) \\times filter(k,l) \\) The sharpened image is then created by adding the edges to the original image, with a scaling factor (See the source code for the full details).","title":"Implementation"}]}